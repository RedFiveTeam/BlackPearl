function setByPath(object, path, value) {
  var ref = object;
  var lastKey = path;

  if (path.indexOf('.') !== -1) {
    var keys = path.split('.');

    lastKey = keys.pop();
    ref = keys.reduce(function (res, prop) {
      return res[prop] = res[prop] || {};
    }, object);
  }

  ref[lastKey] = value;
}

function rulesToQuery(ability, action, subject, convert) {
  var query = {};
  var ignoreOperators = {};
  var rules = ability.rulesFor(action, subject);

  for (var i = 0; i < rules.length; i++) {
    var rule = rules[i];
    var op = rule.inverted ? '$and' : '$or';

    if (!rule.conditions) {
      if (rule.inverted) {
        return null;
      }

      if (query[op]) {
        delete query[op];
      }

      ignoreOperators[op] = true;
    } else if (!ignoreOperators.hasOwnProperty(op)) {
      query[op] = query[op] || [];
      query[op].push(convert(rule));
    }
  }

  return rules.length > 0 ? query : null;
}

function rulesToFields(ability, action, subject) {
  return ability.rulesFor(action, subject).filter(function (rule) {
    return !rule.inverted && rule.conditions;
  }).reduce(function (values, rule) {
    return Object.keys(rule.conditions).reduce(function (fields, fieldName) {
      var value = rule.conditions[fieldName];

      if (!value || value.constructor !== Object) {
        setByPath(fields, fieldName, value);
      }

      return fields;
    }, values);
  }, {});
}

var getRuleFields = function getRuleFields(rule) {
  return rule.fields;
};

function permittedFieldsOf(ability, action, subject) {
  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

  var fieldsFrom = options.fieldsFrom || getRuleFields;
  var uniqueFields = ability.possibleRulesFor(action, subject).slice(0).reverse().filter(function (rule) {
    return rule.matches(subject);
  }).reduce(function (fields, rule) {
    var names = fieldsFrom(rule);

    if (names) {
      var toggle = rule.inverted ? 'delete' : 'add';
      names.forEach(fields[toggle], fields);
    }

    return fields;
  }, new Set());

  return Array.from(uniqueFields);
}

var joinIfArray = function joinIfArray(value) {
  return Array.isArray(value) ? value.join(',') : value;
};

function packRules(rules) {
  return rules.map(function (_ref) {
    var actions = _ref.actions,
        subject = _ref.subject,
        conditions = _ref.conditions,
        inverted = _ref.inverted,
        fields = _ref.fields,
        reason = _ref.reason;

    // eslint-disable-line
    var rule = [joinIfArray(actions), joinIfArray(subject), conditions || 0, inverted ? 1 : 0, joinIfArray(fields) || 0, reason || 0];

    while (!rule[rule.length - 1]) {
      rule.pop();
    }return rule;
  });
}

function unpackRules(rules) {
  return rules.map(function (_ref2) {
    var actions = _ref2[0],
        subject = _ref2[1],
        conditions = _ref2[2],
        inverted = _ref2[3],
        fields = _ref2[4],
        reason = _ref2[5];
    return {
      actions: actions.split(','),
      subject: subject.split(','),
      inverted: !!inverted,
      conditions: conditions || null,
      fields: fields ? fields.split(',') : null,
      reason: reason || null
    };
  });
}

export { rulesToQuery, rulesToFields, permittedFieldsOf, packRules, unpackRules };
