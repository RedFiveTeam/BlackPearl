import React, { PureComponent, Fragment, createElement } from 'react';
import PropTypes from 'prop-types';
import { Ability } from '@casl/ability';

var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};

var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};

var noop = function noop() {};
var _renderChildren = Fragment ? function (children) {
  return createElement.apply(null, [Fragment, null].concat(children));
} : React.Children.only;
var propTypes = {};

if (process.env.NODE_ENV !== 'production') {
  var REQUIRED_OBJECT_OR_STRING = PropTypes.oneOfType([PropTypes.object, PropTypes.string]).isRequired;

  var alias = function alias(names, validate) {
    return function (props) {
      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      // eslint-disable-line
      if (!names.split(' ').some(function (name) {
        return props[name];
      })) {
        return validate.apply(undefined, [props].concat(args));
      }
    };
  };

  propTypes = {
    I: alias('do', PropTypes.string.isRequired),
    a: alias('on this of an', REQUIRED_OBJECT_OR_STRING),
    an: alias('on this of a', REQUIRED_OBJECT_OR_STRING),
    of: alias('on a this an', REQUIRED_OBJECT_OR_STRING),
    this: alias('on a of an', REQUIRED_OBJECT_OR_STRING),
    do: alias('I', PropTypes.string.isRequired),
    on: alias('this a of an', REQUIRED_OBJECT_OR_STRING),
    not: PropTypes.bool,
    passThrough: PropTypes.bool,
    children: PropTypes.any.isRequired,
    ability: PropTypes.instanceOf(Ability).isRequired
  };
}

var Can = function (_PureComponent) {
  inherits(Can, _PureComponent);

  function Can() {
    classCallCheck(this, Can);

    for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    var _this = possibleConstructorReturn(this, _PureComponent.call.apply(_PureComponent, [this].concat(args)));

    _this.unsubscribeFromAbility = noop;
    _this.state = {
      ability: _this.props.ability,
      allowed: false
    };
    return _this;
  }

  Can.prototype.componentWillReceiveProps = function componentWillReceiveProps(props) {
    if (props.ability && this.state.ability !== props.ability) {
      this.setState({ ability: props.ability });
      this.connectToAbility(props.ability);
    } else {
      this.recheck(props);
    }
  };

  Can.prototype.componentWillMount = function componentWillMount() {
    this.connectToAbility(this.state.ability);
  };

  Can.prototype.componentWillUnmount = function componentWillUnmount() {
    this.unsubscribeFromAbility();
  };

  Can.prototype.connectToAbility = function connectToAbility(ability) {
    var _this2 = this;

    this.unsubscribeFromAbility();

    if (ability) {
      this.unsubscribeFromAbility = ability.on('updated', function () {
        return _this2.recheck();
      });
      this.recheck();
    }
  };

  Can.prototype.recheck = function recheck(props) {
    return this.setState({ allowed: this.check(props) });
  };

  Can.prototype.check = function check() {
    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

    var params = props || this.props;

    var _split = (params.I || params.do).split(/\s+/),
        action = _split[0],
        field = _split[1];

    var subject = params.of || params.a || params.this || params.on;
    var can = params.not ? 'cannot' : 'can';

    return this.state.ability[can](action, subject, field);
  };

  Can.prototype.render = function render() {
    var canRender = this.props.passThrough || this.state.allowed;
    return canRender ? this.renderChildren() : null;
  };

  Can.prototype.renderChildren = function renderChildren() {
    var children = this.props.children;

    var elements = typeof children === 'function' ? children(this.state.allowed, this.state.ability) : children;

    return _renderChildren(elements);
  };

  createClass(Can, [{
    key: 'allowed',
    get: function get$$1() {
      return this.state.allowed;
    }
  }]);
  return Can;
}(PureComponent);

Can.propTypes = propTypes;

function createCanBoundTo(ability) {
  var _class, _temp;

  return _temp = _class = function (_Can) {
    inherits(BoundCan, _Can);

    function BoundCan() {
      classCallCheck(this, BoundCan);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      var _this = possibleConstructorReturn(this, _Can.call.apply(_Can, [this].concat(args)));

      _this.state.ability = _this.state.ability || ability;
      return _this;
    }

    return BoundCan;
  }(Can), _class.propTypes = Object.assign({}, Can.propTypes, {
    ability: PropTypes.instanceOf(Ability)
  }), _temp;
}

function createContextualCan(Consumer) {
  return function ContextualCan(props) {
    return createElement(Consumer, null, function (ability) {
      return createElement(Can, {
        ability: props.ability || ability,
        I: props.I || props.do,
        a: props.on || props.a || props.an || props.of || props.this,
        not: props.not,
        children: props.children,
        passThrough: props.passThrough
      });
    });
  };
}

export { Can, createCanBoundTo, createContextualCan };
